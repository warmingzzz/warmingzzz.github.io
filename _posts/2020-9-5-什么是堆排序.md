---
layout: post
title: '什么是堆排序'
date: 2020-8-31
author: 温
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: 排序
---

二叉堆（Binary Heap）是一颗特殊的完全二叉树，分为大顶堆和小顶堆。

我们以一个数组arr=[5、1、4、2、8、4]开始

![](/assets/img/dui1.jpg)

我们首先以这个数组建立一个大顶堆，插入节点5作为根节点：

![](/assets/img/dui2.jpg)

然后将结点1插入到最后一个位置，也就是结点5的左孩子，1<5，满足大顶堆的属性：

![](/assets/img/dui3.jpg)

将结点4插入到最后一个位置，即结点5的右孩子，因为4<5，满足大顶堆的属性，不需要调整

![](/assets/img/dui4.jpg)

将结点2插入到最后一个位置，即结点1的左孩子位置，但是此时不满足大顶堆的属性（插入节点2小于父节点1的值），所以交换两者的值；此时并没结束，判断此时插入节点2与当前结点5的大小关系，发现2<5，满足大顶堆的属性，判断结束。

![](/assets/img/dui6.jpg)

紧接着将结点8插入到最后一个位置，即结点2的右孩子位置，此时不满足大顶堆的属性，故交换两者的位置；然后继续向上修正，判断当前结点8与父结点5的大小关系，8>5（不满足大顶堆的属性），交换两者位置，继续修正，发现结点8已经是树额度根结点，修正结束：

![](/assets/img/dui7.jpg)

![](/assets/img/dui8.jpg)

最后，将结点4插入到最后一个位置，即结点4（下标为2）的左孩子的位置，且值小于等于父结点，不用修正：

![](/assets/img/dui9.jpg)

以上全部是对于二叉堆插入操作的一个回顾，建堆的过程，接下来才是堆排序的核心操作。

设n表示堆中的元素个数，对数组arr=[8,5,4,1,2,4]而言，n=6

第一步：将顶堆的元素8（即数组arr[0],最大元素）的元素与堆最后一个元素4（即数组当中最后一个元素）交换，此时相当于选出数组中最大的元素，将其从堆中去掉：

![](/assets/img/dui10.jpg)

第二步：从结点4（下表为0）开始进行堆化操作！！计算结点4（下表为0）的左孩子left=2*i+1=1（即结点5），右孩子right=2*i+2（即结点4），比较三者大小，发现5>4违反了堆的性质，交换5和根节点4；然后继续堆结点4（下标为1）进行判断，发现其左孩子1和右孩子2均小于4，堆话结束。

![](/assets/img/dui11.jpg)

第三步：将堆顶元素5（下标为0）和当前最后一个元素2（即i指向的位置）交换，此时就相当于选出了数组当前的此最大元素，将其从堆中去掉：

![](/assets/img/dui12.jpg)

第四步：从当前的堆顶元素2开始进行堆话操作，交换2（下标为0）和左孩子4（下标为1），为什么不是右孩子4（下标2）呢？因为堆话的时候，优先和左孩子进行对比，**只有右孩子大于左孩子的情况下**，才考虑将右孩子与其父结点交换，堆化后的结果如下图

![](/assets/img/dui13.jpg)

第五步：交换根节点4和最后一个结点1，从堆中去掉结点4（下标3）：

![](/assets/img/dui14.jpg)

第六步：从根结点 1 开始进行堆化操作，交换了根结点 1 和 4 （下标 2）：

![](/assets/img/dui15.jpg)

第七步：交换根结点 4 和 1 ，从堆中去掉结点 4 ：

![](/assets/img/dui16.jpg)

第八步：从根结点 1 开始进行堆化操作，交换了结点 2 和 1 ：

![](/assets/img/dui17.jpg)

第九步：交换根结点 2 和最后一个元素 1 ，将结点 2 从堆中去掉：

![](/assets/img/dui18.jpg)

第十步：发现堆中仅剩余一个元素，堆排序结束，我们看到原始的输入数组   arr = [5、1、4、2、8、4]  变成了有序数组   arr = [1、2、4、4、5、8]  。
这就是有趣有好玩的堆排序，其本质上是对二叉堆的一个应用。我们都知道选择排序是利用线性的时间复杂度 O（n） 遍历数组，每一趟选择出数组当中最大的元素，总共选择 n-1趟，所以选择排序的时间复杂度为 O（n^2）。
而堆排序事实上就是对选择排序的一个优化，本来用  O（n）的时间才能选择出数组中最大或最小元素，借助于大顶堆和小顶堆数据结构，就可以将这个选择操作的时间复杂度降到  O（log n），同样是选择  n-1趟，所以堆排序的时间复杂度为 O（n log n)量级。
不难发现，堆排序是一个基于比较的排序算法，且在排序过程中由于要进行堆化操作（不断交换）（Heapify），而造成其**不稳定性**，所以堆排序是一个不稳定的排序算法。

```java
public class HeapSort 
{ 
    public void heapSort(int arr[]) 
    { 
        int n = arr.length; 
  
        //建堆（你也可以考虑进行上面的插入操作）但是这里调用的是Heapify
        //可以达到同样的建堆效果
        for (int i = n / 2 - 1; i >= 0; i--){
         heapify(arr, n, i); 
        } 

        //从堆中一个一个地选择出最大元素
        for (int i = n-1; i > 0; i--) 
        { 
            // 交换堆的根结点(最大元素)与当前最后一个元素(i)
            int temp = arr[0]; 
            arr[0] = arr[i]; 
            arr[i] = temp; 
  
            // 在去掉最后一个元素的堆上进行堆化操作
            heapify(arr, i, 0); 
        } 
    } 
  
    // 堆化操作
    void heapify(int arr[], int n, int i) 
    { 
        int largest = i; // 初始化最大元素为根结点
        int l = 2*i + 1; // i 的左孩子结点 left = 2*i + 1 
        int r = 2*i + 2; // i 的右孩子结点 right = 2*i + 2 
  
        // 如果左孩子结点比根结点大，更新largest为左孩子
        if (l < n && arr[l] > arr[largest]) 
            largest = l; 
  
        // 如果右孩子比最大元素大，更新largest为右孩子
        if (r < n && arr[r] > arr[largest]) 
            largest = r; 
  
        // 如果最大元素不是根结点，进行交换操作并递归调用Heapify
        if (largest != i) 
        { 
            int swap = arr[i]; 
            arr[i] = arr[largest]; 
            arr[largest] = swap; 
  
            // 对由于交换操作受到影响的子树递归调用Heapify
            heapify(arr, n, largest); 
        } 
    } 
    public static void main(String args[]) 
    { 
        int arr[] = {5,1,4,2,8,4}; 
        int n = arr.length; 
  
        HeapSort ob = new HeapSort(); 
        ob.sort(arr); 
  
        for(int i = 0; i < n; i++){
            System.out.print(arr[i] + ",")
        }
    } 
} 
```

