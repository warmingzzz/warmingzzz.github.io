---
layout: post
title: 'java垃圾回收机制'
date: 2020-10-28
author: Warmingzzz
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: java
---

>GC算法

### 一、概括

理解Java虚拟机垃圾回收机制的底层原理是系统调优与线上问题的排查，也是高级java程序员的基本功，本文针对Java垃圾回收这一主题做一些整理与记录。



JDK8下的默认垃圾回收器：UseParallelGC：新生代+老年代 堆内存回收机制

### 二、如何判断对象是否可以回收？

首先有一个问题，内存堆中有那么多对象，回收器要回收那些对象？怎么判断这些对象需要回收？

判断对象是否可以回收一般两种方法。

第一种、引用计算器算法：每当对象被引用一次计数器就加1，对象失去引用计数器就-1，计数器为0是可以判断对象死亡了。这种算法简单高效，但是对于循环引用或其他复杂情况，**需要更多而外的开销，因此java几乎不用改算法。**

第二种、根搜索算法--可达性分析算法：所谓可达性分析是指，顺着GCRoots根一直向下搜索，整个搜索的过程就构成了一条引用链，只要在引用链上的对象就叫可达。在引用链外就不可达，不可达的对象可以判断为可回收的对象。哪些对象可作为GCRoots对象呢？

** 虚拟机栈帧上本地变量表中的引用对象（方法参数、局部变量、临时变量）

** 方法区中的静态属性引用对象等等、、、、

![image-20201028100436131](/assets/img/image-20201028100436131.png)

![image-20201028100453501](/assets/img/image-20201028100453501.png)

GCRoots其实很好理解，他们是程序运行时的源头，程序的正常运行必须依赖他们，而这些源头没有任何关系的对象，即可以理解为可回收对象，好比“瓜从藤上掉下，那这瓜肯定也没用了”

不过要注意的是，可达性分析从理论上很好理解，在实际垃圾收集器具体运行的时候考虑的东西要复杂很多倍，因为在可达性分析的同时，程序也是在并行运行着，整个内存堆的状态随着程序的运行实时变化的，要实现分析结果与内存状态的一致性，要必须暂停用户的线程去比较，这并不现实。

### 三、垃圾回收算法

可达性分析解决了判断对象是否可以回收的问题，那么垃圾回收时内存空间会发生哪些变化呢？这就是垃圾回收器讨论的问题了，我们根据算法对内存采取的不同操作，可将垃圾回收算法分为三种，标记-清除算法、标记-复制算法，标记-整理算法。

3.1标记-清楚算法

根据名称就可以理解该算法分为两个阶段：首先标记出所有需要被回收的对象，然后对标记的对象进行统一清楚，对象所占用的内存区域，下图展示了回收前与回收后区域的对比，红色的表示可回收对象，橙色表示不可回收对象，白色表示内存空白区域。

![image-20201028102327058](/assets/img/image-20201028102327058.png)

标记-清楚的两个缺点：

1、执行效率不可控，如果堆中大部分的对象都是可回收的，收集器要执行大量的标记、收集操作。

2、产生了许多内存碎片，通过回收后的区域很多都是不连续的，当有大对象要分配而找不到满足大小的空间时，要触发下一次垃圾收集。

### 3.2 标记—复制算法

针对标记—清除算法执行效率与内存碎片的缺点，计算机科学家提出了一种“半复制区域”算法。

标记—复制算法将内存分为大小相同的两个区域，运行区域，预留区域，所有创建的新对象都要分配到运行区域，当运行区域内存不够时，将运行区域中存活的对象全部复制到预留区域，然后清空整个运行区域内存，这是两个区域的角色也发生了变化，每次存活的对象就像皮球一样在两个区域之间踢来踢去。

![image-20201028103019408](/assets/img/image-20201028103019408.png)

#### 优缺点

优点：标记—复制算法在大量垃圾对象的情况下，只需要复制少量的存活对象，并且不会产生内存碎片的问题，新内存的分配需要移动堆顶指针顺序分配即可，很好兼顾了效率和内存碎片的问题。

缺点：预留一倍的区域十分浪费，并且如果区域中大部分的对象时存活状态，少量垃圾对象，收集器要执行多次复制操作才能释放少量内存空间，得不偿失。

### 3.3 标记—清除算法

该算法对标记—复制算法进行了改进，复制算法因为需要浪费一般的内存空间，标记整理算法的标记阶段和其他算法一样，但是在整理阶段，算法将存活的内存空间移向内存空间的一端，然后将存活对象边界以外的空间全部清空。

![image-20201028103653510](/assets/img/image-20201028103653510.png)

缺点：内存中存活对象多并且都是一些微小对象时，垃圾对象少时，需要移动大量的存活对象才能换取少量的内存空间。

不同的垃圾回收算法都有各自的优缺点，适用于不同的垃圾回收场景。

### 四、新生代、老年代堆内存结构

![image-20201028103844459](/assets/img/image-20201028103844459.png)

新生代、老年代，默认情况下新生代占1/3的空间，老年代占2/3的空间，新生代还分为Eden区 **Survial区，Survial又分为S0、S1区 默认各占8/10与1/10，1/10的空间**。

**垃圾回收的理论基础：**

绝大多数的对象都是临时生存即创建不久即可消亡；

熬过越多的垃圾回收区域对象就越难消亡。

一块独立的内存区域只能使用一种回收算法，根据对象的生命周期特征，将其划分到不同的区域，在对特定区域使用特定的垃圾回收算法，只有这才能将垃圾回收算法的优点发挥到极致，这种组合的垃圾回收算法叫：分代垃圾算法。比如：在新生代使用标记—复制算法，在老年代使用标记—整理算法。

### 五、堆内存回收过程详解

1、假设在第一次垃圾回收，内存的状态如图所示，Eden区有两个存活对象，三个垃圾对象，内存的可用区域已经所剩无几，Survivor区因为还没有进行任何MinorGC所以是空的，有1个大对象直接分配到了老年代，

![image-20201028104906239](/assets/img/image-20201028104906239.png)

2、第一次执行MinorGC

当新的对象分配到Eden区，发现内存空间不够，于是触发第一次MinorGC，垃圾回收器首先将Edne区中的两个存活对象复制到S0区，然后在清空Eden区的空间，如下图：

![image-20201028104943377](/assets/img/image-20201028104943377.png)

3、程序运行后一段时间

经过一段时间之后，堆内存状态如下：Eden区有产生了大量的对象，并且大部分对象都可以回收

![image-20201028105051709](/assets/img/image-20201028105051709.png)

4、执行第二次MinorGC

新对象分配Eden区空间不足，又触发了第二次MinorGC，第二次MinorGC与第一次GC时在Eden区的操作是一样的：将Eden区存活的对象复制到S1区，然后在清空整个Eden区，同时也将S0区存活的对象复制到S1区并将对象的年龄加1，再清空S0区，GC后的状态如下图所示：

![image-20201028105128134](/assets/img/image-20201028105128134.png)

5、程序运行后一段时间

经过第二MinorGC后程序又运行了一段时间，Eden区中有生成了很多对象，S1区也有一个对象可回收。

![image-20201028105152630](/assets/img/image-20201028105152630.png)

6、第15次MinorGC后的内存状态

在接下来的每次MinorGC时，都是第二次一样，从Eden区和survivor非空白区移动存活对象到survivor区中空白区域，并清空这两个区域内存空间，存活对象每此从survivor两个区域移动一次，对象年龄加1，下图表示经过了15次MinorGC后的堆内存状态。

![image-20201028105243425](/assets/img/image-20201028105243425.png)

7、对象如何进入老年代

第一种情况：超过Eden区域大小

第二种情况：从年轻代晋升到老年代

### 5.8老年代回收算法—FullGC

当有对象要进入老年代，而老年代空间又不足时就会触发FullGC，当然，反过来说触发FullGC的条件不仅仅只是老年代空间不足，FullGC使用的算法是上面说的标记-整理算法。

![image-20201028105530758](/assets/img/image-20201028105530758.png)

![image-20201028105542429](/assets/img/image-20201028105542429.png)

### 六、总结

> -  判断对象是否可以回收是垃圾回收的基础与前提，通过可达性分析从GCRoots开始进行"顺藤摸瓜"找到不可达对象（可回收）
> - 对象生命周期的特征"朝生夕灭"与"越战越强"是垃圾回收算法的理论基础
> - 基础的垃圾回收算法有3种分别是 标记-清除算法、标记—复制算法、标记—整理算法，都有各自的适应场合与优缺点
> - 分代垃圾算法根据对象生命周期的特征，将其划分到不同的区域，从而使用最适合的垃圾算法来进行优化
> - 在JDK8默认的配置下使用 新生代，老年代的垃圾回收策略，新生代区域使用标记-复制算法，老年代区域使用标记-整理算法

﻿

