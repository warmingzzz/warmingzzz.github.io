---
layout: post
title: 'Huffman编码'
date: 2020-8-31
author: 温
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: 编码
---

>第二篇博客

Huffman编码

假设现在我们要对下面这句歌词“we will we will r u”进行压缩。

![Aaron Swartz](https://github.com/warmingzzz/warmingzzz.github.io/blob/master/assets/img/Huffman0.jpeg)

1、如果是使用ASCII码对这句话编码结果则为：119 101 32 119 105 108 108 32 119 101 32 119 105 108 108 32 114 32 117（十进制表示）。我们可以看出需要19个字节，也就是至少需要152位的内存空间去存储这些数据。

上面是每个字符出现的频率 

![Aaron Swartz](https://github.com/warmingzzz/warmingzzz.github.io/blob/master/assets/img/Huffman1.jpeg)

2、Huffman二叉树构建

自底向上的编码！！！每次都从最左边开始编码

无失真压缩编码，没有任何其他整数编码比Huffman编码更短的平均码长，也即它是一种最优码。

那么我们按出现频率高低将其放入一个优先级队列中，从左到右依次为频率逐渐增加。 

第一步：带权合并 



![Aaron Swartz][https://github.com/warmingzzz/warmingzzz.github.io/blob/master/assets/img/Huffman2.jpeg])



这里要重新调整队列 

![Aaron Swartz](https://github.com/warmingzzz/warmingzzz.github.io/blob/master/assets/img/Huffman2.jpeg)

经过多步操作之后，得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树：



![Aaron Swartz](https://github.com/warmingzzz/warmingzzz.github.io/blob/master/assets/img/Huffman3.jpeg)



有了上面带权重的二叉树之后，我们就可以进行编码了。我们把二叉树分支中左边的支路编码为0，右边分支表示为1，如下图：

![Aaron Swartz](https://github.com/warmingzzz/warmingzzz.github.io/blob/master/assets/img/Huffman4.jpeg)

这样依次遍历这颗二叉树就可以获取得到所有字符的编码了。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。

　　最终我们可以得到下面这张编码表：



![Aaron Swartz](https://github.com/warmingzzz/warmingzzz.github.io/blob/master/assets/img/Huffman5.jpeg)

有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2/3空间， 

![Aaron Swartz](https://github.com/warmingzzz/warmingzzz.github.io/blob/master/assets/img/Huffman6.jpeg)

