---
layout: post
title: 'Hashmap之碰撞'
date: 2020-10-8
author: Warmingzzz
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: HashMap
---

>HashMap之Hash碰撞

碰撞的意思是计算得到相同的Hash值，需要放到同一个buckt中，hashmap里面的bucket出现了单链表的形式，散列表要解决的一个问题就是散列表的冲突问题，通常的两种方法就是：链表法和开放地址法。

链表法就是把相同的hash值对象放在一个hash值相同的槽位；开放地址法就是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。

###  链表法

HashMap采用的链表法的方式，链表是单向链表。

当两个Entry的key的hashcode（）相同，那么他们的存储位置相同。如果这两个Entry的key通过equals比较返回true，将新添加entry的value覆盖集合原来的value，但是key不会覆盖。如果equals比较返回false，那么新添加的entry将个集合中的原有entry形成entry链，而且新添加的Entry位于Entry链的头部。



HashMap里面没有出现hash冲突时，没有形成单链表，hashmap查找速度很快，get方法可以直接定位到元素，出先单链表之后单个buckt存储不是一个Entry而是一个Entry链，系统只能必须按照顺序遍历每个Entry，如果查找的元素恰好是第一个添加的，则为最后才能找到。

### 开放地址法

问题：已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表。

解答：为了减少冲突，通常令装填因子α由除余法因子是13的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。

前五个关键字插入时，相应的地址均为开放地址，故将他们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。

当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。

当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。

当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。

类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。

**二次探查法：**如果发生冲突，那么记下这个冲突的位置为index，然后在加上固定步长，即index+step，找到这个位置，看一下是否仍然冲突，如果继续冲突，那么按照这个思路，继续加上固定步长

### Java8碰撞优化提升

如果某个桶中的记录过大当前是TREEIFY_THRESHOLD = 8），HashMap会动态的使用一个专门的treemap实现来替换掉它。这样做的结果会更好，是O(logn)，而不是糟糕的O(n)。



之所以选择红黑树是为了解决二叉查找树的缺陷，**二叉查找树在特殊情况下会变成一条线性结构**（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，链表长度低于6，就把红黑树转回链表，因为根本不需要引入红黑树，引入反而会慢。



