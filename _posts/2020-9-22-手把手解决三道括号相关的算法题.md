---
layout: post
title: '括号相关的算法题'
date: 2020-9-22
author: Warmingzzz
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: 笔试
---

>手把手解决三道括号相关的算法题

20、有效括号

921、使括号有效饿最小插入

1541、平衡括号串的最小插入

### 判断合法括号串

对括号的合法判断多次在笔试中出现，现实中也很常见，比如我们写代码编译器回检查括号是否正确闭合。而且我们写的代码可能包括三种括号[] {} ()，判断起来有一点难度。

有效括号简单，略过....

## 平衡括号串（一）

力扣921题「使括号有效的最少添加」

给你输入一个字符串S，你可以在其中的任意位置插入左括号（或者）右括号，请问你至少需要插入几次才能使能S变成一个合法的括号串？

比如输入S=“（））（”算法应该返回2，因为我们至少需要插入两次把S变成“（（））（）”，这样每个左括号都有一个右括号匹配，S使一个合法的括号串。

这其实和前文的判断括号合法性类似。

我们直接看代码

```java
int minAddToMakeValid(string s) {
    // res 记录插入次数
    int res = 0;
    // need 变量记录右括号的需求量
    int need = 0;

    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(') {
            // 对右括号的需求 + 1
            need++;
        }

        if (s[i] == ')') {
            // 对右括号的需求 - 1
            need--;

            if (need == -1) {
                need = 0;
                // 需插入一个左括号
                res++;
            }
        }
    }

    return res + need;
}
```

这段代码就是最终解法，**核心思想是以左括号为基准，通过维护对右括号的需求need，来计算最小的插入次数**。需要注意的两个地方：

1、当need== -1 的时候意味着什么

因为只有遇到右扣号）的时候才会need --，当need == -1意味着右括号太多了，所以需要插入左括号。

比如说S =“））”这种情况，需要插入2个左括号，使得S变成“（）（）”，才是一个合法的括号串。

### 2、算法为什么返回res+need

因为res记录的左括号插入的次数，need记录右括号的次数，当for循环结束后，若need不为0，那么意味着右括号还不够，需要插入。

比如说S=“））（”这种情况，插入2个左括号之后，还要插入1个右括号，使S变得合法。

## 平衡括号串（二）

这是leetcode1541「平衡括号字符串的最少插入次数」

现在假设一个左括号需要匹配2个右括号才叫合法的括号组合，那么给你输入一个括号字符串S，请问你如何计算使得S合法的最小插入次数呢？

**核心思想还是和刚才一样，通过一个need变量记录对右括号的需求数，根据need的变化判断是否需要插入。**

第一步，我们按照刚才的思路正确维护need变量：

```java
int minInsertions(string s) {
    // need 记录需右括号的需求量
    int res = 0, need = 0;

    for (int i = 0; i < s.size(); i++) {
        // 一个左括号对应两个右括号
        if (s[i] == '(') {
            need += 2;
        }

        if (s[i] == ')') {
            need--;
        }
    }

    return res + need;
}
```



现在想一想，当need为什么值的时候，我们需要进行插入？

首先，类似第一题，当need==-1时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号。

比如S=“）”，我们肯定需要插入一个左括号让S=“（）”，但是由于一个左括号需要两个右括号，所以对右括号的需求量变为1:

```java
if (s[i] == ')') {
    need--;
    // 说明右括号太多了
    if (need == -1) {
        // 需要插入一个左括号
        res++;
        // 同时，对右括号的需求变为 1
        need = 1;
    }
}
```



另外，**当遇到左括号的时候，若对右括号的需求为奇数，需要插入1个右括号**。因为一个左括号需要两个右括号，右括号的需求必须时偶数，这一点也是本题的难点。

```java
if (s[i] == '(') {
    need += 2;
    if (need % 2 == 1) {
        // 插入一个右括号
        res++;
        // 对右括号的需求减一
        need--;
    }
}
```



综上，我们可以写出正确的代码了

```java
int minInsertions(string s) {
    int res = 0, need = 0;

    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(') {
            need += 2;
            if (need % 2 == 1) {
                res++;
                need--;
            }
        }

        if (s[i] == ')') {
            need--;
            if (need == -1) {
                res++;
                need = 1;
            }
        }
    }

    return res + need;
}
```

综上，三道括号相关的问题就解决了，其实我们前文 [合法括号生成算法](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485115&idx=1&sn=dd64bfedb1da22f308228a0933583adf&chksm=9bd7f8b3aca071a5b96e7cb9464c01c045997d36d677b14163b6b009df2aa9b1b613ace3bc5a&scene=21#wechat_redirect) 也是括号相关的问题，但是使用的回溯算法技巧，和本文的几道题差别还是蛮大的，有兴趣的读者可以去看看。

